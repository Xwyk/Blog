{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"post",
				"postId"
			],
			[
				"ne",
				"newPicture"
			],
			[
				"ex",
				"imageExtension"
			],
			[
				"image",
				"imageExtension"
			],
			[
				"ima",
				"imageDir"
			],
			[
				"comment",
				"commentId"
			],
			[
				"sessio",
				"session_destroy"
			],
			[
				"res",
				"result"
			],
			[
				"token",
				"tokenValue"
			],
			[
				"va",
				"var_dump"
			],
			[
				"sess",
				"session_id"
			],
			[
				"crea",
				"createFromArray"
			],
			[
				"check",
				"checkToken"
			],
			[
				"new",
				"newpost"
			],
			[
				"in",
				"input\tTag"
			],
			[
				"reta",
				"retardInactivity"
			],
			[
				"TOKEN_",
				"TOKEN_EXPIRATED"
			],
			[
				"TOKEN",
				"TOKEN_VALID"
			],
			[
				"SESSION_I",
				"SESSION_INACTIVITY_TIME_KEY"
			],
			[
				"SESSION",
				"SESSION_GENERATION_TIME_KEY"
			],
			[
				"SESSIO",
				"SESSION_INACTIVITY_TIME_KEY"
			],
			[
				"tok",
				"token"
			],
			[
				"param",
				"parameters"
			],
			[
				"pos",
				"postId"
			],
			[
				"resut",
				"resultComments"
			],
			[
				"conten",
				"contentFile"
			],
			[
				"URL",
				"URL_BASE"
			],
			[
				"INPUT",
				"INPUT_POST"
			],
			[
				"filter",
				"filter_input"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/D/MySigma/fleboul/OneDrive - SIGMA Informatique/Bureau/na01.pac",
			"settings":
			{
				"buffer_size": 13698,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "anniv568E1W2B\n\nhttps://traveler.socamaine.fr/servlet/traveler\nhttps://traveler.scanormande.fr/servlet/traveler\nhttps://traveler.scaouest.fr/servlet/traveler\nhttps://traveler.leclerc.groupe-sigma.com\n\ncomptadrive > standard\n\nvadredi 4 --",
			"settings":
			{
				"buffer_size": 236,
				"line_ending": "Windows",
				"name": "anniv568E1W2B"
			}
		},
		{
			"file": "index.php",
			"settings":
			{
				"buffer_size": 2252,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 4479 files for \"createfromglobals\"\n\nC:\\tmp\\mabite\\vendor\\symfony\\http-foundation\\Request.php:\n  295       * @return static\n  296       */\n  297:     public static function createFromGlobals()\n  298      {\n  299          $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);\n\n1 match in 1 file\n",
			"settings":
			{
				"buffer_size": 340,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(AcceptHeader::class);\nclass_exists(FileBag::class);\nclass_exists(HeaderBag::class);\nclass_exists(HeaderUtils::class);\nclass_exists(InputBag::class);\nclass_exists(ParameterBag::class);\nclass_exists(ServerBag::class);\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 0b00001; // When using RFC 7239\n    const HEADER_X_FORWARDED_FOR = 0b00010;\n    const HEADER_X_FORWARDED_HOST = 0b00100;\n    const HEADER_X_FORWARDED_PROTO = 0b01000;\n    const HEADER_X_FORWARDED_PORT = 0b10000;\n    const HEADER_X_FORWARDED_ALL = 0b11110; // All \"X-Forwarded-*\" headers\n    const HEADER_X_FORWARDED_AWS_ELB = 0b11010; // AWS ELB doesn't send X-Forwarded-Host\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = [];\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var InputBag|ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var InputBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var InputBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    /**\n     * @var string|null\n     */\n    private $preferredFormat;\n    private $isHostValid = true;\n    private $isForwardedValid = true;\n\n    /**\n     * @var bool|null\n     */\n    private $isSafeContentPreferred;\n\n    private static $trustedHeaderSet = -1;\n\n    private static $forwardedParams = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    private static $trustedHeaders = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',\n        self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new InputBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new InputBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n//     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);\n\n        if ($_POST) {\n            $request->request = new InputBag($_POST);\n        } elseif (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new InputBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create(string $uri, string $method = 'GET', array $parameters = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     */\n    public static function setFactory(?callable $callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new InputBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new InputBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            if (\\PHP_VERSION_ID >= 70400) {\n                throw $e;\n            }\n\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [[]];\n\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST[] = $request[$order];\n        }\n\n        $_REQUEST = array_merge(...$_REQUEST);\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n     * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n     *\n     * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n     */\n    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)\n    {\n        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {\n            if ('REMOTE_ADDR' !== $proxy) {\n                $proxies[] = $proxy;\n            } elseif (isset($_SERVER['REMOTE_ADDR'])) {\n                $proxies[] = $_SERVER['REMOTE_ADDR'];\n            }\n\n            return $proxies;\n        }, []);\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet()\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString(?string $qs)\n    {\n        if ('' === ($qs ?? '')) {\n            return '';\n        }\n\n        parse_str($qs, $qs);\n        ksort($qs);\n\n        return http_build_query($qs, '', '&', PHP_QUERY_RFC3986);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY\n     *\n     * @param mixed $default The default value if the parameter key does not exist\n     *\n     * @return mixed\n     */\n    public function get(string $key, $default = null)\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this->query->has($key)) {\n            return $this->query->all()[$key];\n        }\n\n        if ($this->request->has($key)) {\n            return $this->request->all()[$key];\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface The session\n     */\n    public function getSession()\n    {\n        $session = $this->session;\n        if (!$session instanceof SessionInterface && null !== $session) {\n            $this->setSession($session = $session());\n        }\n\n        if (null === $session) {\n            throw new \\BadMethodCallException('Session has not been set.');\n        }\n\n        return $session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * @internal\n     */\n    public function setSessionFactory(callable $factory)\n    {\n        $this->session = $factory;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see https://wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos && $port = substr($host, $pos + 1)) {\n            return (int) $port;\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath(string $path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath(string $path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see https://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * @return string\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     */\n    public function setMethod(string $method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n        if ('POST' !== $this->method) {\n            return $this->method;\n        }\n\n        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');\n\n        if (!$method && self::$httpMethodParameterOverride) {\n            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n        }\n\n        if (!\\is_string($method)) {\n            return $this->method;\n        }\n\n        $method = strtoupper($method);\n\n        if (\\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {\n            return $this->method = $method;\n        }\n\n        if (!preg_match('/^[A-Z]++$/D', $method)) {\n            throw new SuspiciousOperationException(sprintf('Invalid method override \"%s\".', $method));\n        }\n\n        return $this->method = $method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType(string $format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @return array The associated mime types\n     */\n    public static function getMimeTypes(string $format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format] : [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat(?string $mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat(?string $format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @see getPreferredFormat\n     *\n     * @return string|null The request format\n     */\n    public function getRequestFormat(?string $default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->attributes->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     */\n    public function setRequestFormat(?string $format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     */\n    public function setDefaultLocale(string $locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     */\n    public function setLocale(string $locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod(string $method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @return bool\n     */\n    public function isMethodSafe()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     *\n     * @return bool\n     */\n    public function isMethodIdempotent()\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool True for GET and HEAD, false otherwise\n     */\n    public function isMethodCacheable()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     *\n     * @return string\n     */\n    public function getProtocolVersion()\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via'), $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent(bool $asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Gets the preferred format for the response by inspecting, in the following order:\n     *   * the request format set using setRequestFormat;\n     *   * the values of the Accept HTTP header.\n     *\n     * Note that if you use this method, you should send the \"Vary: Accept\" header\n     * in the response to prevent any issues with intermediary HTTP caches.\n     */\n    public function getPreferredFormat(?string $default = 'html'): ?string\n    {\n        if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {\n            return $this->preferredFormat;\n        }\n\n        foreach ($this->getAcceptableContentTypes() as $mimeType) {\n            if ($this->preferredFormat = $this->getFormat($mimeType)) {\n                return $this->preferredFormat;\n            }\n        }\n\n        return $default;\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param string[] $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = [];\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!\\in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (\\count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = \\count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /**\n     * Checks whether the client browser prefers safe content or not according to RFC8674.\n     *\n     * @see https://tools.ietf.org/html/rfc8674\n     */\n    public function preferSafeContent(): bool\n    {\n        if (null !== $this->isSafeContentPreferred) {\n            return $this->isSafeContentPreferred;\n        }\n\n        if (!$this->isSecure()) {\n            // see https://tools.ietf.org/html/rfc8674#section-3\n            $this->isSafeContentPreferred = false;\n\n            return $this->isSafeContentPreferred;\n        }\n\n        $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');\n\n        return $this->isSafeContentPreferred;\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (https://framework.zend.com/license).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (https://www.zend.com/)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrl())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if (false === $pathInfo || '' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded'],\n        ];\n    }\n\n    private function setPhpDefaultLocale(string $locale): void\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /**\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, null otherwise.\n     */\n    private function getUrlencodedPrefix(string $string, string $prefix): ?string\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return null;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return null;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null): self\n    {\n        if (self::$requestFactory) {\n            $request = (self::$requestFactory)($query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     *\n     * @return bool true if the request came from a trusted proxy, false otherwise\n     */\n    public function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues(int $type, string $ip = null): array\n    {\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if ((self::$trustedHeaderSet & $type) && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_X_FORWARDED_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if ((self::$trustedHeaderSet & self::HEADER_FORWARDED) && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwarded = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $parts = HeaderUtils::split($forwarded, ',;=');\n            $forwardedValues = [];\n            $param = self::$forwardedParams[$type];\n            foreach ($parts as $subParts) {\n                if (null === $v = HeaderUtils::combine($subParts)[$param] ?? null) {\n                    continue;\n                }\n                if (self::HEADER_X_FORWARDED_PORT === $type) {\n                    if (']' === substr($v, -1) || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $v = '0.0.0.0'.$v;\n                }\n                $forwardedValues[] = $v;\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, string $ip): array\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (0 === strpos($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n}\n",
			"file": "/C/tmp/mabite/vendor/symfony/http-foundation/Request.php",
			"file_size": 65879,
			"file_write_time": 132416306344800477,
			"settings":
			{
				"buffer_size": 65881,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Install Package Control"
			],
			[
				"insta",
				"Install Package Control"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 124.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/wamp64/www/Blog",
		"/C/wamp64/www/Blog/Controller"
	],
	"file_history":
	[
		"/C/wamp64/www/Blog/Model/User.php",
		"/C/wamp64/www/Blog/View/content/admin.php",
		"/C/wamp64/www/Blog/Controller/RegisterController.php",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/Base File.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/Alignment/Base File.sublime-settings",
		"/C/wamp64/www/Blog/Model/Post.php",
		"/C/wamp64/www/Blog/Framework/Session.php",
		"/C/wamp64/www/Blog/Controller/PostController.php",
		"/C/wamp64/www/Blog/View/content/home.php",
		"/C/wamp64/www/Blog/Model/Comment.php",
		"/C/wamp64/www/Blog/Framework/Entity.php",
		"/C/wamp64/www/Blog/Exceptions/PostNotFoundException.php",
		"/C/wamp64/www/Blog/Framework/View.php",
		"/C/wamp64/www/Blog/Model/Manager/UserManager.php",
		"/C/wamp64/www/Blog/Model/Manager/PostManager.php",
		"/C/wamp64/www/Blog/View/content/editPost.php",
		"/C/wamp64/www/Blog/View/content/post.php",
		"/C/wamp64/www/Blog/Model/Manager/TokenManager.php",
		"/C/wamp64/www/Blog/View/pages/template.php",
		"/C/wamp64/www/Blog/Framework/Manager.php",
		"/C/wamp64/www/Blog/View/content/addPost.php",
		"/C/wamp64/www/Blog/Model/Token.php",
		"/C/wamp64/www/Blog/Model/Manager/CommentManager.php",
		"/C/wamp64/www/Blog/Framework/SecuredController.php",
		"/C/wamp64/www/Blog/Framework/Controller.php",
		"/C/wamp64/www/Blog/index.php",
		"/C/wamp64/www/Blog/View/content/login.php",
		"/C/wamp64/www/Blog/View/content/register.php",
		"/C/wamp64/www/Blog/Framework/Configuration.php",
		"/C/wamp64/www/Blog/Controller/AdminController.php",
		"/C/wamp64/www/Blog/Controller/HomeController.php",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Settings/SideBarEnhancements.json",
		"/C/wamp64/www/Blog/Controller/LoginController.php",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/SideBarEnhancements/Default (Windows).sublime-keymap",
		"/C/wamp64/www/Blog/Controller/CommentController.php",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/SideBarEnhancements/Open With/Side Bar.sublime-menu",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/SideBarEnhancements/Side Bar.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/Side Bar.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/Phpcs/Default (Windows).sublime-keymap",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/Emmet/Emmet.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/AutoFileName/autofilename.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/Alignment/Default (Windows).sublime-keymap",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/BracketHighlighter/Example.sublime-keymap",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/SublimeGit/Default.sublime-keymap",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/phpcs.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/SublimeGit/SublimeGit.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/SublimeGit.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/Phpcs/phpcs.sublime-settings",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/phar/phpmd.bat",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/phar/phpcbf.bat",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/phar/php-cs-fixer.bat",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/phar/phpcs.bat",
		"/C/Users/fleboul/AppData/Roaming/Sublime Text 3/Packages/User/Emmet.sublime-settings",
		"/C/wamp64/www/Blog/Exceptions/AlreadyUsedMailAddressException.php",
		"/C/wamp64/www/Blog/Exceptions/ExpiredSessionException.php",
		"/C/wamp64/www/Blog/Exceptions/ExpiredTokenException.php",
		"/C/wamp64/www/Blog/Exceptions/FileNotFoundException.php",
		"/C/wamp64/www/Blog/Exceptions/FileNotValidException.php",
		"/C/wamp64/www/Blog/Exceptions/InvalidTokenException.php",
		"/C/wamp64/www/Blog/Exceptions/NotEnoughRightsException.php",
		"/C/wamp64/www/Blog/Exceptions/UserNotActiveException.php",
		"/C/wamp64/www/Blog/Exceptions/UserNotConnectedException.php",
		"/C/wamp64/www/Blog/Exceptions/UserNotFoundException.php",
		"/C/wamp64/www/Blog/Exceptions/WrongPasswordException.php",
		"/C/wamp64/www/Blog/composer.json",
		"/C/wamp64/www/Blog/README.md",
		"/C/wamp64/www/Blog/Framework/Token.php",
		"/C/wamp64/www/Blog/vendor/twig/twig/src/Extension/DebugExtension.php",
		"/C/wamp64/www/Blog/config/config.local.php",
		"/C/wamp64/www/Blog/Common/themes/css/DataTables-1.10.21/js/jquery.dataTables.js",
		"/C/wamp64/www/Blog/config/config.php",
		"/C/wamp64/www/Blog/Common/themes/js/datatables.min.js",
		"/C/wamp64/www/Blog/.gitignore",
		"/C/Users/fleboul/Desktop/LD-Magasin-Paridis.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Administratif.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Textile-Chaussures.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Bazar Saisonnier.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Encadrement.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Equipement Maison.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Frais Trad.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-PFLS.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-PGC.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Resp. Rayon.txt",
		"/C/Users/fleboul/Desktop/LD-Paridis-Restauration.txt"
	],
	"find":
	{
		"height": 40.6666666667
	},
	"find_in_files":
	{
		"height": 104.8,
		"where_history":
		[
			"C:\\tmp\\mabite\\vendor\\symfony",
			"C:\\wamp64\\www\\Blog",
			"<current file>",
			"C:\\wamp64\\www\\Blog\\Controller,C:\\wamp64\\www\\Blog\\Exceptions,C:\\wamp64\\www\\Blog\\Framework,C:\\wamp64\\www\\Blog\\Model",
			"C:\\wamp64\\www\\Blog\\Exceptions\\AlreadyUsedMailAddressException.php,C:\\wamp64\\www\\Blog\\Exceptions\\ExpiredSessionException.php,C:\\wamp64\\www\\Blog\\Exceptions\\ExpiredTokenException.php,C:\\wamp64\\www\\Blog\\Exceptions\\FileNotFoundException.php,C:\\wamp64\\www\\Blog\\Exceptions\\FileNotValidException.php,C:\\wamp64\\www\\Blog\\Exceptions\\InvalidTokenException.php,C:\\wamp64\\www\\Blog\\Exceptions\\NotEnoughRightsException.php,C:\\wamp64\\www\\Blog\\Exceptions\\PostNotFoundException.php,C:\\wamp64\\www\\Blog\\Exceptions\\UserNotActiveException.php,C:\\wamp64\\www\\Blog\\Exceptions\\UserNotConnectedException.php,C:\\wamp64\\www\\Blog\\Exceptions\\UserNotFoundException.php,C:\\wamp64\\www\\Blog\\Exceptions\\WrongPasswordException.php",
			"<current file>,C:\\wamp64\\www\\Blog",
			"C:\\wamp64\\www\\Blog",
			"<current file>"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"createRequestFromFactory",
			"requestFactory",
			"createfromglobals",
			"$_post",
			"_session",
			"files",
			"newId",
			"getId",
			"$_",
			"\\r\\n",
			"\"\\r\\n\"",
			"\\r\\n",
			"\"C:\\\\Program Files (x86)\\\\PHP\\\\tools\\\\",
			"\t",
			"link",
			"postModificationDate",
			"getActive",
			"SESSION_INACTIVITY_LOGOUT_MINUTES",
			"expirated",
			"generated",
			"var_dump(.*);",
			"var_dump(*);",
			"checkSession",
			"checksession",
			"10",
			"createFromArray",
			"tokenValue",
			"bin2hex(openssl_random_pseudo_bytes",
			"session",
			"sessionId",
			"Session",
			"self::",
			"retardInactivity",
			"getToken",
			"retardInactivity",
			"SESSION_INACTIVITY_MINUTES",
			"$expirationDate",
			"expirationDate",
			"tokenGeneration",
			"static ",
			"self::",
			"static ",
			"self::",
			"No data available in table",
			"no data",
			"render",
			"isval",
			"\"search\"",
			"search",
			"\"Next\"",
			"\"Previous\"",
			"\"previous\"",
			"previous",
			"filtered",
			"entries",
			"limog",
			"limo",
			"surg"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"\\n",
			"\"C:\\\\Users\\\\fleboul\\\\AppData\\\\Roaming\\\\Sublime Text 3\\\\phar\\\\",
			"    ",
			"EXPIRED",
			"",
			"$this::",
			"SESSION_INACTIVITY_LOGOUT_MINUTES",
			"$this->tokenExpirationTime",
			"tokenExpirationTime",
			"tokenGenerationTime",
			"",
			"$this->",
			"",
			"$this->",
			"Aucune donnée dans la table",
			"\"Suivant\"",
			"\"Précédent\"",
			"\"Previous\""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/D/MySigma/fleboul/OneDrive - SIGMA Informatique/Bureau/na01.pac",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13698,
						"regions":
						{
						},
						"selection":
						[
							[
								13649,
								13682
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content"
							],
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6866.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 236,
						"regions":
						{
						},
						"selection":
						[
							[
								236,
								236
							]
						],
						"settings":
						{
							"auto_name": "anniv568E1W2B",
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "index.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2252,
						"regions":
						{
						},
						"selection":
						[
							[
								522,
								522
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										2213,
										2214
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"region.purplish"
									]
								},
								"open":
								{
									"1":
									[
										521,
										522
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 340,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										182,
										199
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"default_dir": "C:\\wamp64\\www\\Blog",
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/C/tmp/mabite/vendor/symfony/http-foundation/Request.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 65881,
						"regions":
						{
						},
						"selection":
						[
							[
								7654,
								7654
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										7686,
										7687
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/round_bracket.png",
										"region.yellowish"
									]
								},
								"open":
								{
									"1":
									[
										7639,
										7640
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3812.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "blog.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 308.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
